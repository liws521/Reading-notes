# Meta
- 正则表达式入门级别的一本不错的书, 更像是一本用户入门学习手册而非一本字典级参考手册, 正如作者所说, 在学习和使用正则表达式的时候，重要的并不是你知道多少个特殊字符，而是你会不会运用它们去解决实际问题, 学以致用, 致用以学, 最近我的问题在于为了学习而学习, 而非为了应用而学习, 事倍功半, 人的精力有限, 时间有限, 又哪能做到样样深耕呢, 对于接触的大多领域都只需掌握一些核心概念和基本语法就好

# 正则表达式必知必会
## 引言
- 在学习和使用正则表达式的时候，重要的并不是你知道多少个特殊字符，而是你会不会运用它们去解决实际问题
    - 学以致用, 致用以学, 最近我的问题在于为了学习而学习, 而非为了应用而学习, 事倍功半
    - 精力有限, 时间有限, 又哪能做到样样深耕呢, 对于接触的大多领域都只需掌握一些核心概念和基本语法就好.
- 本书架构, 从简单的字符串匹配开始入手, 后序介绍一些复杂一些的专题, e.g. 回溯引用/后向引用(backreference), 条件性求值(conditional evaluation)和前后查找(looking-around)

## C1 正则表达式入门
- regular expression -> regex
- 用途, 进行文本匹配+[替换]
- 比较迷你, 一般嵌入到其他工具中, 应用程序大多用菜单访问regex, 程序设计语言大都通过函数or类来使用regex
- 计算机从来都是做中学学科, 不经过实践的学习在CS领域事倍功半
## C2 匹配单个字符
- . 除换行符以外的任意单个字符, 如果需要.的本身含义, 用转义字符\
## C3 匹配一组字符
- 用[]定义一个字符集合, 里面可以写想要匹配的字符, e.g. [ab], 
    - 在[]中使用-可以定义一个字符区间, e.g. [A-Za-z0-9] 在[]外使用-就是一个普通的字符, 所以在regex中使用-不需要被转义
- [^a-z0-9], 先定义一个字符区间, 而后对其取非, 而不是只对^后跟着的字符区间取非
## C4 使用元字符
- 前面接触到的元字符, `. [ ] \`
- 空白元字符
    - [\b] 回退(并删除)一个字符(Backspace键), 这个是用来匹配退格字符的, 不在\s中
    - \f 换页符
    - \n 换行符, \r 回车符, \t 制表符
    - \v 垂直制表符
    - \d is [0-9], \D is [^0-9]
    - \w is [a-zA-Z0-9_], \W is ^ of \w
    - \s is [\f\n\r\t\v], 任意一个空白字符, \S任意非空字符
- POSIX字符类, 一种字符集合中的简写形式, 并非所有的regex的实现都支持
## C5 重复匹配
- +, 一到多, [0-9]+, 代表1-多个连续数字
    - 注意区分[0-9+], 匹配一个字符, 可以是数字或+
- *, 零到多
- ?, 0 or 1
    - 解决Windows/Linux系统下回车问题就可以用 [\r]?\n
    - 写\r?\n也是一样的, 第一种写法定义一个字符集合, 集合里只有\r这样的一种字符, 和第二种写法功能相同, 对读者更友好一点, 读起来不会有歧义.
- 上述三种都是元字符, 匹配本身需要转义, 放到字符集合里也是本身, 加了转义也没什么问题
- 制定精确的重复次数{}
    - {a} 重复a次
    - {a, b} 重复[a, b]次
    - {a, } 至少重复a次
- *, +, {a, }这三个都没有上限, 都是贪婪型的, 尽可能匹配的长
- *?, +?, {a, }?是其对于的懒惰版本, 尽可能匹配的短
## C6 位置匹配
- the border of a word(w in Vim)
- \< matches the pos of \W and \w, \> matches that of \w and \W
- \b matches the pos of \w and \W or that of \W and \w
- the border of a string(W in Vim)
- ^ matches the start of a string, $ matches end
- (?m), regard \n as a start/end of string
## C7 子表达式
- 用元字符()进行分组
## C8 回溯引用backreference
- 解决HTML中Head标签匹配, 用`<[hH][1-6]>.*?</[hH][1-6]>`来找出所有的head标签, 现在存在的问题是<h2>a</h3>也会被匹配进来, 也就是结束标签对开始标签的情况一无所知, 回溯引用就是用来解决这类问题的
- 比如匹配两个连续的单词怎么实现, 需要先知道第一个单词是什么, 才能控制第二个和它一不一样, 实现 `[ ]+(\w+)[ ]+\1`
    - [ ]+代表1-多个space, 用()把\w+括起来, 做成一个子表达式, 然后用\1引用pattern中的第一个子表达式, 想一下Java中对正则表达式的实现, 把子表达式的sIndex和eIndex+1存到groups[2]和groups[3]中, 后续即可引用
- 这种按位置的捕获方式用\数字进行引用, 当想改逻辑的时候可能要改的地方有点多, 可以用`命名捕获`, 给子表达式起个名字, 这样改变相对位置也不用改后面引用位置的语句了, 命名捕获是否支持要看具体的实现
## C9 前后查找lookaround
- regex常见的实现都支持向前查找lookahead, 部分支持向后查找lookbehind, Java是支持的
## C10 嵌入条件
- 当前面是不同的匹配时向后找不同的匹配, 类似于编程语言中的三元运算符
## 附录A

### A.12 Perl
- m/pattern/
- s/pattern/pattern/